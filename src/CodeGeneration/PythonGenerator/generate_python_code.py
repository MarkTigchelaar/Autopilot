import symbols

# This file contains the code to generate Python code from the renamed code blocks
# It has python specific code as strings, which would not be seen in the other code generators
class PythonFilePrinter:
    def __init__(self, output_file):
        self.output_file = output_file
        self.indent_level = 0
        self.lines = list()
        self.python_module_imports = dict()

    def open_file(self):
        self.file = open(self.output_file + ".py", "w")

    def close_file(self):
        self.file.close()

    def write(self):
        self.add_prelude()
        self.open_file()
        for line in self.lines:
            self.file.write(line + "\n")
        self.close_file()

    def inc_scope_level(self):
        self.indent_level += 1

    def dec_scope_level(self):
        self.indent_level -= 1

    def add_prelude(self):
        prelude = list()
        prelude.append("# Autogenerated code from Autopilot Compiler")
        prelude.append("# Autopilot Programming Language made by Mark Tigchelaar")
        # compiler_defined_types = self.add_non_python_type_aliases()
        prelude.append(
            "from __future__ import annotations # For delayed type evaluation, to define classes, enums etc. after type defines"
        )
        for module_name in self.python_module_imports:
            import_statement = f"from {module_name} import " + ", ".join(
                list(self.python_module_imports[module_name])
            )
            prelude.append(import_statement)
        # prelude.extend(compiler_defined_types)
        prelude.append("\n")
        prelude.append("string = str")
        prelude.append("char = str")
        prelude.append("true = True")
        prelude.append("false = False")
        prelude.append("long = int")
        prelude.append("double = float")

        self.lines = prelude + self.lines

    def add_import(self, module_name, item):
        if module_name not in self.python_module_imports:
            self.python_module_imports[module_name] = set()
        self.python_module_imports[module_name].add(item)

    def write_to_buffer(self, line):
        whitespace = " " * (4 * self.indent_level)
        self.lines.append(whitespace + line)


def generate_python_code(renamed_code_blocks, output_file):
    printer = PythonFilePrinter(output_file)
    #print("here in generate_python_code")
    generate_system_import_defs(printer, renamed_code_blocks)

    for define_statement in renamed_code_blocks.key_value_defines:
        generate_key_value_type(
            printer, define_statement.sub_type, define_statement.new_type_name_token
        )
    for define_statement in renamed_code_blocks.linear_type_defines:
        generate_linear_type(
            printer, define_statement.sub_type, define_statement.new_type_name_token
        )
    for define_statement in renamed_code_blocks.failable_type_defines:
        generate_failable_type(
            printer, define_statement.sub_type, define_statement.new_type_name_token
        )
    for define_statement in renamed_code_blocks.function_type_defines:
        generate_function_type(
            printer, define_statement.sub_type, define_statement.new_type_name_token
        )
    
    printer.write_to_buffer("\n\n")
    for enum_statement in renamed_code_blocks.enums:
        generate_enum(printer, enum_statement)
    for union_statement in renamed_code_blocks.unions:
        generate_unions(printer, union_statement)
    for error_statement in renamed_code_blocks.errors:
        generate_error(printer, error_statement)
    for interface_statement in renamed_code_blocks.interfaces:
        generate_interface(printer, interface_statement)
    for struct_statement in renamed_code_blocks.structs:
        generate_struct(printer, struct_statement)
    for function_statement in renamed_code_blocks.functions:
        generate_function(printer, function_statement)
    for unit_test in renamed_code_blocks.unit_tests:
        pass

    printer.write_to_buffer("\n\n")
    printer.write_to_buffer("if __name__ == '__main__':")
    printer.write_to_buffer("    main_main()")
    printer.write()


def generate_key_value_type(printer, key_value_type, new_type_name_token):
    if key_value_type.descriptor_token.literal == "Dictionary":
        printer.add_import("collections", "OrderedDict")
        line = f"{new_type_name_token.literal} = OrderedDict[{key_value_type.key_token.literal}, {key_value_type.value_token.literal}]"

    else:
        printer.add_import("typing", "Dict")
        line = f"{new_type_name_token.literal} = Dict[{key_value_type.key_token.literal}, {key_value_type.value_token.literal}]"
    printer.write_to_buffer(line + " # type: ignore")


def generate_linear_type(printer, linear_type, new_type_name_token):
    if linear_type.descriptor_token.literal == "LinkedList":
        # Being lazy for now, should make a generic linked list type
        printer.add_import("typing", "List")
        line = (
            f"{new_type_name_token.literal} = List[{linear_type.value_token.literal}]"
        )

    elif linear_type.descriptor_token.literal == "List":
        printer.add_import("typing", "List")
        line = (
            f"{new_type_name_token.literal} = List[{linear_type.value_token.literal}]"
        )
    elif linear_type.descriptor_token.literal == "Vector":
        # Aslo beinglazy here, should make a generic vector type
        printer.add_import("typing", "List")
        line = (
            f"{new_type_name_token.literal} = List[{linear_type.value_token.literal}]"
        )
    elif linear_type.descriptor_token.literal == "Stack":
        printer.add_import("typing", "List")
        line = (
            f"{new_type_name_token.literal} = List[{linear_type.value_token.literal}]"
        )
    elif linear_type.descriptor_token.literal == "Queue":
        printer.add_import("queue", "Queue")
        line = (
            f"{new_type_name_token.literal} = Queue[{linear_type.value_token.literal}]"
        )
    elif linear_type.descriptor_token.literal == "FifoQueue":
        printer.add_import("queue", "Queue")
        line = (
            f"{new_type_name_token.literal} = Queue[{linear_type.value_token.literal}]"
        )
    elif linear_type.descriptor_token.literal == "PriorityQueue":
        printer.add_import("queue", "PriorityQueue")
        line = f"{new_type_name_token.literal} = PriorityQueue[{linear_type.value_token.literal}]"
    elif linear_type.descriptor_token.literal == "Deque":
        printer.add_import("collections", "Deque")
        line = (
            f"{new_type_name_token.literal} = Deque[{linear_type.value_token.literal}]"
        )
    else:
        raise Exception(f"Unknown linear type: {linear_type.descriptor_token.literal}")
    printer.write_to_buffer(line + " # type: ignore")


def generate_failable_type(printer, sub_type, new_type_name_token):
    if sub_type.descriptor_token.literal == "Option":
        printer.add_import("typing", "Optional")
        line = (
            f"{new_type_name_token.literal} = Optional[{sub_type.value_token.literal}]"
        )
    elif sub_type.descriptor_token.literal == "Result":
        printer.add_import("typing", "TypeVar")
        line = f"{new_type_name_token.literal} = TypeVar({sub_type.error_token.literal}, {sub_type.value_token.literal})"
    else:
        raise Exception(f"Unknown failable type: {sub_type.descriptor_token.literal}")
    printer.write_to_buffer(line + " # type: ignore")


def generate_function_type(printer, sub_type, new_type_name_token):
    printer.add_import("typing", "Callable")
    args = ", ".join([arg.literal for arg in sub_type.arg_type_list])
    line = f"{new_type_name_token.literal} = Callable[[{args}], {sub_type.return_type_token.literal}]"
    printer.write_to_buffer(line + " # type: ignore")


def generate_enum(printer, enum_statement):
    printer.add_import("enum", "Enum")

    line = f"class {enum_statement.name_token.literal}(Enum):"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    for item in enum_statement.filled_in_items:
        line = f"{item.item_name} = {item.default_value}"
        printer.write_to_buffer(line)
    printer.write_to_buffer("\n\n")
    printer.dec_scope_level()

def generate_unions(printer, union_statement):
    printer.add_import("enum", "Enum")
    printer.add_import("dataclasses", "dataclass")
    printer.add_import("typing", "Any")
    printer.write_to_buffer("# Union statement tag")
    line = f"class {union_statement.name_token.literal}Tag(Enum):"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    for i, item in enumerate(union_statement.items):
        line = f"{item.item_name_token.literal}: int = {i}"
        printer.write_to_buffer(line)
    printer.dec_scope_level()
    printer.write_to_buffer("")
    printer.write_to_buffer("# Union statement")
    printer.write_to_buffer("@dataclass")
    
    line = f"class {union_statement.name_token.literal}:"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    printer.write_to_buffer(
        f"def __init__(self, tag: {union_statement.name_token.literal}Tag, value: Any):"
    )
    printer.inc_scope_level()
    printer.write_to_buffer("self.tag = tag")
    printer.write_to_buffer("self.value = value")
    printer.dec_scope_level()
    printer.dec_scope_level()
    printer.write_to_buffer("\n")



def generate_error(printer, error_statement):
    printer.write_to_buffer("# Error type tag:")
    printer.add_import("enum", "Enum")
    printer.add_import("typing", "Any")
    line = f"class {error_statement.name_token.literal}Tag(Enum):"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    for i, item_token in enumerate(error_statement.items):
        line = f"{item_token.literal} = {i}"
        printer.write_to_buffer(line)
    printer.write_to_buffer("")
    printer.dec_scope_level()
    printer.write_to_buffer("# Error type:")
    printer.write_to_buffer(f"class {error_statement.name_token.literal}:")
    printer.inc_scope_level()
    printer.write_to_buffer(
        f"def __init__(self, tag: {error_statement.name_token.literal}Tag, value: Any):"
    )
    printer.inc_scope_level()
    printer.write_to_buffer("self.tag = tag")
    printer.write_to_buffer("self.value = value")
    printer.dec_scope_level()
    printer.dec_scope_level()
    printer.write_to_buffer("\n")


def generate_interface(printer, interface_statement):
    printer.add_import("typing", "Protocol")
    line = f"class {interface_statement.name_token.literal}(Protocol):"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    for method in interface_statement.fn_headers:
        args = ", ".join(
            [
                f"{arg.arg_name_token.literal}: {arg.arg_type_token.literal}"
                for arg in method.arguments
            ]
        )
        return_type = None
        if method.return_type_token is not None:
            return_type = method.return_type_token.literal
        line = f"def {method.name_token.literal}(self, {args}) -> {return_type}:"
        printer.write_to_buffer(line)
        printer.inc_scope_level()
        printer.write_to_buffer("...")
        printer.dec_scope_level()
    printer.dec_scope_level()
    printer.write_to_buffer("\n")


def generate_struct(printer, struct_statement):
    printer.add_import("dataclasses", "dataclass")
    printer.write_to_buffer("@dataclass")
    interfaces = struct_statement.get_interfaces()
    inheritances = ""
    if len(interfaces) > 0:
        inheritances = ", ".join([interface.literal for interface in interfaces])
        inheritances = f"({inheritances})"
    line = f"class {struct_statement.name_token.literal}{inheritances}:"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    for field in struct_statement.fields:
        type_info = ""
        if field.type_token is not None:
            type_info = f": {field.type_token.literal}"
        line = f"{field.field_name_token.literal}{type_info}"
        printer.write_to_buffer(line)
    printer.write_to_buffer("")
    for function in struct_statement.functions:
        generate_function(printer, function, is_method=True)
    printer.dec_scope_level()
    printer.write_to_buffer("\n")


def generate_function(printer, function_statement, is_method=False):
    self_arg = ""
    if is_method:
        self_arg = "self, "
    args = self_arg + ", ".join(
        [
            f"{arg.arg_name_token.literal}: {arg.arg_type_token.literal}"
            for arg in function_statement.header.arguments
        ]
    )

    return_type = None
    if function_statement.header.return_type_token is not None:
        return_type = function_statement.header.return_type_token.literal

    line = (
        f"def {function_statement.header.name_token.literal}({args}) -> {return_type}:"
    )
    printer.write_to_buffer(line)
    generate_statements(printer, function_statement.statements)
    printer.write_to_buffer("\n")


def generate_statements(printer, statements):
    printer.inc_scope_level()
    # printer.write_to_buffer("...")
    defer_statements = list()
    for statement in statements:
        if str(statement.__class__.__name__) == "DeferStatement":
            defer_statements.append(statement)
        else:
            generate_statement(printer, statement, defer_statements)

    printer.dec_scope_level()


def generate_statement(printer, statement, defer_statements=[]):
    match str(statement.__class__.__name__):
        case "AssignmentStatement":
            generate_assignment(printer, statement)
        case "ReturnStatement":
            for defer_statement in defer_statements:
                generate_statement(printer, defer_statement)
            generate_return(printer, statement)
        case "IfStatement":
            generate_if(printer, statement)
        case "ElifStatement":
            generate_elif_assign(printer, statement)
        case "ElseStatement":
            generate_else_assign(printer, statement)
        case "UnlessStatement":
            generate_unless_assign(printer, statement)
        case "WhileStatement":
            generate_while(printer, statement)
        case "ContinueStatement":
            for defer_statement in defer_statements:
                generate_statement(printer, defer_statement)
            generate_continue(printer, statement)
        case "BreakStatement":
            for defer_statement in defer_statements:
                generate_statement(printer, defer_statement)
            generate_break(printer, statement)
        case "DeferStatement":
            generate_defer(printer, statement)
        case "LoopStatement":
            generate_loop(printer, statement)
        case "SwitchStatement":
            generate_switch(printer, statement)
        case "ForStatement":
            generate_for(printer, statement)
        case "ReassignmentOrMethodCall":
            generate_reassign_or_method_call(printer, statement)
        case _:
            print(f"Unknown statement type in generate statement function: {type(statement)}")


def generate_assignment(printer, statement):
    type_info = ""
    if statement.type_token is not None:
        type_info = f": {statement.type_token.literal}"
    else:
        raise Exception("Assignment statement must have a type")
    line = f"{statement.name_token.literal}{type_info} = {generate_expression(statement.exp_ast)}"
    printer.write_to_buffer(line)


def generate_reassign_or_method_call(printer, statement):
    assignment_operator = ""
    if statement.assignment_token is not None:
        assignment_operator = " " + statement.assignment_token.literal + " "

    r_value_exp = ""
    if statement.r_value_exp is not None:
        r_value_exp = generate_expression(statement.r_value_exp)

    line = f"{generate_expression(statement.l_value_exp)}{assignment_operator}{r_value_exp}"
    printer.write_to_buffer(line)


def generate_if(printer, statement):
    optional_type = statement.get_optional_name()
    if optional_type is not None:
        line = f"if {optional_type.literal} is not None:"
        printer.write_to_buffer(line)
        line = f"{statement.get_variable_name().literal} = {optional_type.literal}"
        printer.inc_scope_level()
        printer.write_to_buffer(line)
        printer.dec_scope_level()
    else:
        line = f"if {generate_expression(statement.get_expression_ast())}:"
        printer.write_to_buffer(line)
    generate_statements(printer, statement.statements)
    if statement.next_statement_in_block is not None:
        generate_statement(printer, statement.next_statement_in_block)


def generate_elif_assign(printer, statement):
    optional_type = statement.get_optional_name()
    if optional_type is not None:
        line = f"elif {optional_type.literal} is not None:"
        printer.write_to_buffer(line)
        line = f"{statement.get_variable_name().literal} = {optional_type.literal}"
        printer.inc_scope_level()
        printer.write_to_buffer(line)
        printer.dec_scope_level()
    else:
        line = f"elif {generate_expression(statement.get_expression_ast())}:"
        printer.write_to_buffer(line)
    generate_statements(printer, statement.statements)
    if statement.next_statement_in_block is not None:
        generate_statement(printer, statement.next_statement_in_block)


def generate_else_assign(printer, statement):
    line = "else:"
    printer.write_to_buffer(line)
    generate_statements(printer, statement.statements)


def generate_unless_assign(printer, statement):
    line = f"if not ({generate_expression(statement.get_expression_ast())}):"
    printer.write_to_buffer(line)
    generate_statements(printer, statement.statements)


def generate_switch(printer, statement):
    line = f"match {generate_expression(statement.get_test_expression())}:"
    printer.write_to_buffer(line)
    printer.inc_scope_level()
    for case in statement.case_statements:
        rhs = []
        if case.has_enum_references():
            for enum_reference in case.get_enum_references():
                rhs.append(f"{enum_reference.get_enum_name().literal}.{enum_reference.get_field().literal}")
        else:
            rhs = [value.literal for value in case.get_values()]
        line = f"case {' | '.join(rhs)}:"
        printer.write_to_buffer(line)
        generate_statements(printer, case.get_statements())
    if statement.default_case is not None:
        printer.write_to_buffer("case _:")
        generate_statements(printer, statement.default_case.get_statements())
    printer.dec_scope_level()


def generate_return(printer, statement):
    ast = ""
    if statement.get_expression_ast() is not None:
        ast = " " + generate_expression(statement.get_expression_ast())
    line = f"return{ast}"
    printer.write_to_buffer(line)


def generate_for(printer, statement):
    if statement.is_optional_type():
        line = f"for {statement.get_unwrapped_optional_variable_name().literal} in {statement.get_optional_variable_name().literal}:"
        printer.write_to_buffer(line)
        printer.inc_scope_level()
        line = f"if {statement.get_unwrapped_optional_variable_name().literal} is None:"
        printer.write_to_buffer(line)
        printer.inc_scope_level()
        line = f"continue"
        printer.write_to_buffer(line)
        printer.dec_scope_level()
        printer.dec_scope_level()
    elif statement.is_collection_iteration():
        value = ""
        if statement.get_map_value_name() is not None:
            value = f", {statement.get_map_value_name().literal}"
        optional_method = ""
        if value != "":
            optional_method = ".items()"
        line = f"for {statement.get_index_or_key_name().literal}{value} in {statement.get_collection_name().literal}{optional_method}:"
        printer.write_to_buffer(line)
    elif statement.get_index_start_name() is not None:
        iter_size = ""
        if statement.get_iteration_step_size() is not None:
            iter_size = f", {statement.get_iteration_step_size().literal}"
        line = f"for {statement.get_index_or_key_name().literal} in range({statement.get_index_start_name().literal}, {statement.get_index_stop_name().literal}{iter_size}):"
        # line = f"{statement.get_variable_name().literal} = {statement.get_optional_variable_name().literal}"
        printer.write_to_buffer(line)
    
    generate_statements(printer, statement.statements)


def generate_while(printer, statement):
    line = f"while {generate_expression(statement.get_expression_ast())}:"
    printer.write_to_buffer(line)
    generate_statements(printer, statement.statements)


def generate_loop(printer, statement):
    printer.write_to_buffer("while True:")
    generate_statements(printer, statement.statements)


def generate_continue(printer, statement):
    line = f"continue"
    printer.write_to_buffer(line)


def generate_break(printer, statement):
    line = f"break"
    printer.write_to_buffer(line)


def generate_defer(printer, statement):
    # line = f"{generate_expression(statement.method_call)} # defer"
    # printer.write_to_buffer(line)
    generate_reassign_or_method_call(printer, statement.method_call)


def generate_expression(exp_ast):
    match str(exp_ast.__class__.__name__):
        case "OperatorExpression":
            return generate_binary_expression(exp_ast)
        case "PrefixExpression":
            return generate_prefix_expression(exp_ast)
        case "NameExpression":
            return generate_name_expression(exp_ast)
        case "FunctionCallExpression":
            return generate_function_call_expression(exp_ast)
        case "CollectionAccessExpression":
            return generate_collection_access_expression(exp_ast)
        case "MethodCallOrFieldExpression":
            return generate_method_call_expression(exp_ast)
        case "CollectionExpression":
            return generate_collection_expression(exp_ast)
        case _:
            print(f"Unknown expression type: {type(exp_ast)}")


def generate_binary_expression(exp_ast):
    left = generate_expression(exp_ast.get_lhs_exp())
    right = generate_expression(exp_ast.get_rhs_exp())
    operator_literal = exp_ast.get_name().literal
    if operator_literal == "^":
        operator_literal = "**"
    if exp_ast.get_name().get_type() == symbols.COLON:
        return f"{left} {operator_literal} {right}"
    return f"({left} {operator_literal} {right})"


def generate_prefix_expression(exp_ast):
    return f"({exp_ast.token.literal}({generate_expression(exp_ast.rhs_exp)}))"


def generate_name_expression(exp_ast):
    return exp_ast.token.literal


def generate_method_call_expression(exp_ast):
    struct_name = generate_expression(exp_ast.get_lhs_exp())
    methods_and_fields = []
    for method_or_field in exp_ast.get_field_or_methods():
        exp = generate_expression(method_or_field)
        methods_and_fields.append(exp)
    return f"{struct_name}.{'.'.join(methods_and_fields)}"


def generate_function_call_expression(exp_ast):
    fn_name = generate_expression(exp_ast.get_name())
    args = []
    for arg in exp_ast.get_argument_list():
        arg_exp = generate_expression(arg)
        # For function calls, argument exppressions
        # should not contain outer ()
        arg_exp = arg_exp.lstrip("(").rstrip(")")
        args.append(arg_exp)
    return f"{fn_name}({', '.join(args)})"


def generate_collection_expression(exp_ast):
    elements = []
    for element in exp_ast.get_collection_elements():
        exp = generate_expression(element)
        elements.append(exp)
    left_delineator = ""
    right_delinator = ""
    match exp_ast.left_type:
        case "LEFT_BRACKET":
            left_delineator = "["
        case "LEFT_BRACE":
            left_delineator = "{"
        case _:
            print(f"Unknown collection type: {exp_ast.left_type}")
    match exp_ast.rhs_type:
        case "RIGHT_BRACKET":
            right_delinator = "]"
        case "RIGHT_BRACE":
            right_delinator = "}"
        case _:
            print(f"Unknown collection type: {exp_ast.rhs_type}")
    return f"{left_delineator} {', '.join(elements)} {right_delinator}"


def generate_collection_access_expression(exp_ast):
    collection = generate_expression(exp_ast.get_name())
    args = [generate_expression(arg) for arg in exp_ast.get_argument_list()]
    return f"{collection}[{','.join(args)}]"



def generate_system_import_defs(printer, renamed_code_blocks):
    pass


# def map_system_types_and_function_calls(renamed_code_blocks):
#     built_in_libs = renamed_code_blocks.built_in_libs
#     for function_statement in renamed_code_blocks.functions:
#         for statement in function_statement.statements:
            